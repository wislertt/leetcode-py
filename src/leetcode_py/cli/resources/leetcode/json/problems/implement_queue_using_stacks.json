{
    "problem_name": "implement_queue_using_stacks",
    "solution_class_name": "MyQueue",
    "problem_number": "232",
    "problem_title": "Implement Queue using Stacks",
    "difficulty": "Easy",
    "topics": "Stack, Design, Queue",
    "_tags": {
        "list": ["grind-75"]
    },
    "readme_description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n- `void push(int x)` Pushes element x to the back of the queue.\n- `int pop()` Removes the element from the front of the queue and returns it.\n- `int peek()` Returns the element at the front of the queue.\n- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.",
    "_readme_examples": {
        "list": [
            {
                "content": "```\nInput\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n```\n**Explanation:**\n```\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```"
            }
        ]
    },
    "readme_constraints": "- 1 <= x <= 9\n- At most 100 calls will be made to push, pop, peek, and empty.\n- All the calls to pop and peek are valid.",
    "readme_additional": "**Notes:**\n- You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.\n- Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\n**Follow-up:** Can you implement the queue such that each operation is amortized `O(1)` time complexity? In other words, performing `n` operations will take overall `O(n)` time even if one of those operations may take longer.",
    "helpers_imports": "",
    "helpers_content": "",
    "helpers_run_name": "my_queue",
    "helpers_run_signature": "(solution_class: type, operations: list[str], inputs: list[list[int]])",
    "helpers_run_body": "    queue = None\n    results: list[int | None | bool] = []\n    for i, op in enumerate(operations):\n        if op == 'MyQueue':\n            queue = solution_class()\n            results.append(None)\n        elif op == 'push' and queue is not None:\n            queue.push(inputs[i][0])\n            results.append(None)\n        elif op == 'pop' and queue is not None:\n            results.append(queue.pop())\n        elif op == 'peek' and queue is not None:\n            results.append(queue.peek())\n        elif op == 'empty' and queue is not None:\n            results.append(queue.empty())\n    return results, queue",
    "helpers_assert_name": "my_queue",
    "helpers_assert_signature": "(result: list[int | None | bool], expected: list[int | None | bool]) -> bool",
    "helpers_assert_body": "    assert result == expected\n    return True",
    "solution_imports": "",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_my_queue, run_my_queue\nfrom .solution import MyQueue",
    "test_content": "",
    "test_class_name": "ImplementQueueUsingStacks",
    "test_class_content": "",
    "_solution_methods": {
        "list": [
            {
                "name": "__init__",
                "signature": "(self) -> None",
                "body": "        # TODO: Initialize\n        pass"
            },
            {
                "name": "push",
                "signature": "(self, x: int) -> None",
                "body": "        # TODO: Implement push\n        pass"
            },
            {
                "name": "pop",
                "signature": "(self) -> int",
                "body": "        # TODO: Implement pop\n        return 0"
            },
            {
                "name": "peek",
                "signature": "(self) -> int",
                "body": "        # TODO: Implement peek\n        return 0"
            },
            {
                "name": "empty",
                "signature": "(self) -> bool",
                "body": "        # TODO: Implement empty\n        return True"
            }
        ]
    },
    "_test_helper_methods": {
        "list": []
    },
    "_test_methods": {
        "list": [
            {
                "name": "test_queue_operations",
                "signature": "(self, operations: list[str], inputs: list[list[int]], expected: list[int | None | bool])",
                "parametrize": "operations, inputs, expected",
                "test_cases": {
                    "list": [
                        "(['MyQueue', 'push', 'push', 'peek', 'pop', 'empty'], [[], [1], [2], [], [], []], [None, None, None, 1, 1, False])",
                        "(['MyQueue', 'empty', 'push', 'peek', 'pop', 'empty'], [[], [], [1], [], [], []], [None, True, None, 1, 1, True])",
                        "(['MyQueue', 'push', 'push', 'push', 'pop', 'pop', 'peek', 'pop', 'empty'], [[], [1], [2], [3], [], [], [], [], []], [None, None, None, None, 1, 2, 3, 3, True])",
                        "(['MyQueue', 'push', 'peek', 'pop'], [[], [5], [], []], [None, None, 5, 5])",
                        "(['MyQueue', 'push', 'push', 'pop', 'push', 'peek'], [[], [1], [2], [], [3], []], [None, None, None, 1, None, 2])",
                        "(['MyQueue', 'empty'], [[], []], [None, True])",
                        "(['MyQueue', 'push', 'push', 'push', 'push', 'pop', 'pop', 'pop', 'pop', 'empty'], [[], [1], [2], [3], [4], [], [], [], [], []], [None, None, None, None, None, 1, 2, 3, 4, True])",
                        "(['MyQueue', 'push', 'pop', 'push', 'pop', 'empty'], [[], [7], [], [8], [], []], [None, None, 7, None, 8, True])",
                        "(['MyQueue', 'push', 'push', 'peek', 'peek', 'pop', 'peek'], [[], [9], [8], [], [], [], []], [None, None, None, 9, 9, 9, 8])",
                        "(['MyQueue', 'push', 'push', 'push', 'push', 'push', 'pop', 'pop', 'pop', 'push', 'peek'], [[], [1], [2], [3], [4], [5], [], [], [], [6], []], [None, None, None, None, None, None, 1, 2, 3, None, 4])",
                        "(['MyQueue', 'push', 'empty', 'pop', 'empty', 'push', 'empty'], [[], [1], [], [], [], [2], []], [None, None, False, 1, True, None, False])",
                        "(['MyQueue', 'push', 'push', 'push', 'pop', 'push', 'pop', 'pop', 'push', 'pop'], [[], [1], [2], [3], [], [4], [], [], [5], []], [None, None, None, None, 1, None, 2, 3, None, 4])"
                    ]
                },
                "body": "        result, _ = run_my_queue(MyQueue, operations, inputs)\n        assert_my_queue(result, expected)"
            }
        ]
    },
    "playground_imports": "from helpers import run_my_queue, assert_my_queue\nfrom solution import MyQueue",
    "playground_setup": "# Example test case\noperations = ['MyQueue', 'push', 'push', 'peek', 'pop', 'empty']\ninputs = [[], [1], [2], [], [], []]\nexpected = [None, None, None, 1, 1, False]",
    "playground_run": "result, queue = run_my_queue(MyQueue, operations, inputs)\nprint(result)\nqueue",
    "playground_assert": "assert_my_queue(result, expected)"
}
