{
    "problem_name": "maximum_profit_in_job_scheduling",
    "solution_class_name": "Solution",
    "problem_number": "1235",
    "problem_title": "Maximum Profit in Job Scheduling",
    "difficulty": "Hard",
    "topics": "Array, Binary Search, Dynamic Programming, Sorting",
    "_tags": {
        "list": ["grind-75"]
    },
    "readme_description": "We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.\n\nYou're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.",
    "_readme_examples": {
        "list": [
            {
                "content": "![Example 1](https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png)\n\n```\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\nOutput: 120\n```\n**Explanation:** The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70."
            },
            {
                "content": "![Example 2](https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png)\n\n```\nInput: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\nOutput: 150\n```\n**Explanation:** The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60."
            },
            {
                "content": "![Example 3](https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png)\n\n```\nInput: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\nOutput: 6\n```"
            }
        ]
    },
    "readme_constraints": "- `1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4`\n- `1 <= startTime[i] < endTime[i] <= 10^9`\n- `1 <= profit[i] <= 10^4`",
    "readme_additional": "",
    "helpers_imports": "",
    "helpers_content": "",
    "helpers_run_name": "job_scheduling",
    "helpers_run_signature": "(solution_class: type, start_time: list[int], end_time: list[int], profit: list[int])",
    "helpers_run_body": "    implementation = solution_class()\n    return implementation.job_scheduling(start_time, end_time, profit)",
    "helpers_assert_name": "job_scheduling",
    "helpers_assert_signature": "(result: int, expected: int) -> bool",
    "helpers_assert_body": "    assert result == expected\n    return True",
    "solution_imports": "",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_job_scheduling, run_job_scheduling\nfrom .solution import Solution",
    "test_content": "",
    "test_class_name": "MaximumProfitInJobScheduling",
    "test_class_content": "    def setup_method(self):\n        self.solution = Solution()",
    "_solution_methods": {
        "list": [
            {
                "name": "job_scheduling",
                "signature": "(self, start_time: list[int], end_time: list[int], profit: list[int]) -> int",
                "body": "        # TODO: Implement job_scheduling\n        return 0"
            }
        ]
    },
    "_test_helper_methods": {
        "list": [
            {
                "name": "setup_method",
                "parameters": "",
                "body": "self.solution = Solution()"
            }
        ]
    },
    "_test_methods": {
        "list": [
            {
                "name": "test_job_scheduling",
                "signature": "(self, start_time: list[int], end_time: list[int], profit: list[int], expected: int)",
                "parametrize": "start_time, end_time, profit, expected",
                "test_cases": {
                    "list": [
                        "([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70], 120)",
                        "([1, 2, 3, 4, 6], [3, 5, 10, 6, 9], [20, 20, 100, 70, 60], 150)",
                        "([1, 1, 1], [2, 3, 4], [5, 6, 4], 6)",
                        "([1, 2], [2, 3], [100, 200], 300)",
                        "([6, 15, 7, 11, 1, 3, 16, 2], [19, 18, 19, 16, 10, 8, 19, 8], [2, 9, 1, 19, 5, 7, 3, 19], 41)",
                        "([1], [2], [100], 100)",
                        "([1, 2, 3], [2, 3, 4], [1, 1, 1], 3)",
                        "([1, 3, 6, 7, 8, 12], [4, 5, 10, 11, 12, 16], [20, 20, 100, 70, 60, 120], 240)",
                        "([1, 4, 6], [3, 5, 7], [50, 10, 40], 100)",
                        "([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [10, 20, 30, 40, 50], 50)",
                        "([5, 4, 3, 2, 1], [6, 5, 4, 3, 2], [1, 2, 3, 4, 5], 15)",
                        "([1, 1000000000], [2, 1000000001], [1, 10000], 10001)"
                    ]
                },
                "body": "        result = run_job_scheduling(Solution, start_time, end_time, profit)\n        assert_job_scheduling(result, expected)"
            }
        ]
    },
    "playground_imports": "from helpers import run_job_scheduling, assert_job_scheduling\nfrom solution import Solution",
    "playground_setup": "# Example test case\nstart_time = [1, 2, 3, 3]\nend_time = [3, 4, 5, 6]\nprofit = [50, 10, 40, 70]\nexpected = 120",
    "playground_run": "result = run_job_scheduling(Solution, start_time, end_time, profit)\nresult",
    "playground_assert": "assert_job_scheduling(result, expected)"
}
