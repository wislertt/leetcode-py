{
    "problem_name": "lru_cache",
    "solution_class_name": "LRUCache",
    "problem_number": "146",
    "problem_title": "LRU Cache",
    "difficulty": "Medium",
    "topics": "Hash Table, Linked List, Design, Doubly-Linked List",
    "_tags": {
        "list": ["grind-75"]
    },
    "readme_description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the `LRUCache` class:\n\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1\n- `void put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.",
    "_readme_examples": {
        "list": [
            {
                "content": "```\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n```"
            }
        ]
    },
    "readme_constraints": "- 1 <= capacity <= 3000\n- 0 <= key <= 10^4\n- 0 <= value <= 10^5\n- At most 2 * 10^5 calls will be made to get and put",
    "readme_additional": "",
    "helpers_imports": "",
    "helpers_content": "",
    "helpers_run_name": "lru_cache",
    "helpers_run_signature": "(solution_class: type, operations: list[str], inputs: list[list[int]])",
    "helpers_run_body": "    cache = None\n    results: list[int | None] = []\n    for i, op in enumerate(operations):\n        if op == 'LRUCache':\n            cache = solution_class(inputs[i][0])\n            results.append(None)\n        elif op == 'get' and cache is not None:\n            results.append(cache.get(inputs[i][0]))\n        elif op == 'put' and cache is not None:\n            cache.put(inputs[i][0], inputs[i][1])\n            results.append(None)\n    return results, cache",
    "helpers_assert_name": "lru_cache",
    "helpers_assert_signature": "(result: list[int | None], expected: list[int | None]) -> bool",
    "helpers_assert_body": "    assert result == expected\n    return True",
    "solution_imports": "",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_lru_cache, run_lru_cache\nfrom .solution import LRUCache",
    "test_content": "",
    "test_class_name": "LRUCache",
    "test_class_content": "",
    "_solution_methods": {
        "list": [
            {
                "name": "__init__",
                "signature": "(self, capacity: int) -> None",
                "body": "        # TODO: Initialize LRU cache\n        pass"
            },
            {
                "name": "get",
                "signature": "(self, key: int) -> int",
                "body": "        # TODO: Implement get\n        return -1"
            },
            {
                "name": "put",
                "signature": "(self, key: int, value: int) -> None",
                "body": "        # TODO: Implement put\n        pass"
            }
        ]
    },
    "_test_helper_methods": {
        "list": []
    },
    "_test_methods": {
        "list": [
            {
                "name": "test_lru_cache",
                "signature": "(self, operations: list[str], inputs: list[list[int]], expected: list[int | None])",
                "parametrize": "operations, inputs, expected",
                "test_cases": {
                    "list": [
                        "(['LRUCache', 'put', 'put', 'get', 'put', 'get', 'put', 'get', 'get', 'get'], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]], [None, None, None, 1, None, -1, None, -1, 3, 4])",
                        "(['LRUCache', 'get', 'put', 'get', 'put', 'put', 'get', 'get'], [[2], [2], [2, 6], [1], [1, 5], [1, 2], [1], [2]], [None, -1, None, -1, None, None, 2, 6])",
                        "(['LRUCache', 'put', 'get', 'put', 'get', 'get'], [[1], [2, 1], [2], [3, 2], [2], [3]], [None, None, 1, None, -1, 2])",
                        "(['LRUCache', 'get'], [[1], [1]], [None, -1])",
                        "(['LRUCache', 'put', 'get'], [[1], [1, 100], [1]], [None, None, 100])",
                        "(['LRUCache', 'put', 'put', 'get', 'get'], [[2], [1, 1], [2, 2], [1], [2]], [None, None, None, 1, 2])",
                        "(['LRUCache', 'put', 'put', 'put', 'get', 'get', 'get'], [[2], [1, 1], [2, 2], [3, 3], [1], [2], [3]], [None, None, None, None, -1, 2, 3])",
                        "(['LRUCache', 'put', 'get', 'put', 'get', 'put', 'get'], [[3], [1, 1], [1], [2, 2], [2], [3, 3], [3]], [None, None, 1, None, 2, None, 3])",
                        "(['LRUCache', 'put', 'put', 'put', 'put', 'get', 'get'], [[3], [1, 1], [2, 2], [3, 3], [4, 4], [4], [3]], [None, None, None, None, None, 4, 3])",
                        "(['LRUCache', 'put', 'put', 'get', 'put', 'get', 'get'], [[2], [2, 1], [1, 1], [2], [4, 1], [1], [2]], [None, None, None, 1, None, -1, 1])",
                        "(['LRUCache', 'put', 'put', 'get', 'put', 'put', 'get'], [[2], [2, 1], [2, 2], [2], [1, 1], [4, 1], [2]], [None, None, None, 2, None, None, -1])",
                        "(['LRUCache', 'put', 'put', 'put', 'get', 'put', 'get', 'get', 'get', 'get'], [[3], [1, 1], [2, 2], [3, 3], [2], [4, 4], [1], [3], [4], [2]], [None, None, None, None, 2, None, -1, 3, 4, 2])"
                    ]
                },
                "body": "        result, _ = run_lru_cache(LRUCache, operations, inputs)\n        assert_lru_cache(result, expected)"
            }
        ]
    },
    "playground_imports": "from helpers import run_lru_cache, assert_lru_cache\nfrom solution import LRUCache",
    "playground_setup": "# Example test case\noperations = ['LRUCache', 'put', 'put', 'get', 'put', 'get', 'put', 'get', 'get', 'get']\ninputs = [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nexpected = [None, None, None, 1, None, -1, None, -1, 3, 4]",
    "playground_run": "result, cache = run_lru_cache(LRUCache, operations, inputs)\nprint(result)\ncache",
    "playground_assert": "assert_lru_cache(result, expected)"
}
