{
    "problem_name": "min_stack",
    "solution_class_name": "MinStack",
    "problem_number": "155",
    "problem_title": "Min Stack",
    "difficulty": "Medium",
    "topics": "Stack, Design",
    "_tags": {
        "list": ["grind-75"]
    },
    "readme_description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n\n- `MinStack()` initializes the stack object.\n- `void push(int val)` pushes the element `val` onto the stack.\n- `void pop()` removes the element on the top of the stack.\n- `int top()` gets the top element of the stack.\n- `int getMin()` retrieves the minimum element in the stack.\n\nYou must implement a solution with `O(1)` time complexity for each function.",
    "_readme_examples": {
        "list": [
            {
                "content": "```\nInput\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n```\n**Explanation:**\n```\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n```"
            }
        ]
    },
    "readme_constraints": "- `-2^31 <= val <= 2^31 - 1`\n- Methods `pop`, `top` and `getMin` operations will always be called on **non-empty** stacks.\n- At most `3 * 10^4` calls will be made to `push`, `pop`, `top`, and `getMin`.",
    "readme_additional": "",
    "helpers_imports": "from typing import Any",
    "helpers_content": "",
    "helpers_run_name": "min_stack_operations",
    "helpers_run_signature": "(solution_class: type, operations: list[str], inputs: list[list[int]])",
    "helpers_run_body": "    stack: Any = None\n    results: list[int | None] = []\n    for i, op in enumerate(operations):\n        if op == 'MinStack':\n            stack = solution_class()\n            results.append(None)\n        elif op == 'push' and stack is not None:\n            stack.push(inputs[i][0])\n            results.append(None)\n        elif op == 'pop' and stack is not None:\n            stack.pop()\n            results.append(None)\n        elif op == 'top' and stack is not None:\n            results.append(stack.top())\n        elif op == 'getMin' and stack is not None:\n            results.append(stack.get_min())\n    return results",
    "helpers_assert_name": "min_stack_operations",
    "helpers_assert_signature": "(result: list[int | None], expected: list[int | None]) -> bool",
    "helpers_assert_body": "    assert result == expected\n    return True",
    "solution_imports": "",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_min_stack_operations, run_min_stack_operations\nfrom .solution import MinStack",
    "test_content": "",
    "test_class_name": "TestMinStack",
    "test_class_content": "",
    "_solution_methods": {
        "list": [
            {
                "name": "__init__",
                "signature": "(self) -> None",
                "body": "        # TODO: Initialize MinStack\n        pass"
            },
            {
                "name": "push",
                "signature": "(self, val: int) -> None",
                "body": "        # TODO: Implement push\n        pass"
            },
            {
                "name": "pop",
                "signature": "(self) -> None",
                "body": "        # TODO: Implement pop\n        pass"
            },
            {
                "name": "top",
                "signature": "(self) -> int",
                "body": "        # TODO: Implement top\n        return 0"
            },
            {
                "name": "get_min",
                "signature": "(self) -> int",
                "body": "        # TODO: Implement get_min\n        return 0"
            }
        ]
    },
    "_test_helper_methods": {
        "list": []
    },
    "_test_methods": {
        "list": [
            {
                "name": "test_min_stack",
                "signature": "(self, operations: list[str], inputs: list[list[int]], expected: list[int | None])",
                "parametrize": "operations, inputs, expected",
                "test_cases": {
                    "list": [
                        "(['MinStack', 'push', 'push', 'push', 'getMin', 'pop', 'top', 'getMin'], [[], [-2], [0], [-3], [], [], [], []], [None, None, None, None, -3, None, 0, -2])",
                        "(['MinStack', 'push', 'top', 'getMin', 'pop'], [[], [5], [], [], []], [None, None, 5, 5, None])",
                        "(['MinStack', 'push', 'push', 'push', 'getMin', 'pop', 'getMin', 'pop', 'getMin'], [[], [1], [1], [2], [], [], [], [], []], [None, None, None, None, 1, None, 1, None, 1])",
                        "(['MinStack', 'push', 'getMin', 'top'], [[], [0], [], []], [None, None, 0, 0])",
                        "(['MinStack', 'push', 'push', 'getMin', 'push', 'getMin', 'pop', 'getMin'], [[], [2], [1], [], [0], [], [], []], [None, None, None, 1, None, 0, None, 1])",
                        "(['MinStack', 'push', 'push', 'push', 'top', 'getMin', 'pop', 'pop', 'top', 'getMin'], [[], [3], [1], [4], [], [], [], [], [], []], [None, None, None, None, 4, 1, None, None, 3, 3])",
                        "(['MinStack', 'push', 'push', 'getMin', 'pop', 'push', 'getMin'], [[], [-1], [-2], [], [], [0], []], [None, None, None, -2, None, None, -1])",
                        "(['MinStack', 'push', 'push', 'push', 'push', 'getMin', 'pop', 'pop', 'getMin'], [[], [5], [3], [7], [2], [], [], [], []], [None, None, None, None, None, 2, None, None, 3])",
                        "(['MinStack', 'push', 'push', 'push', 'getMin', 'pop', 'getMin', 'pop', 'getMin', 'pop', 'push', 'getMin'], [[], [10], [5], [15], [], [], [], [], [], [], [8], []], [None, None, None, None, 5, None, 5, None, 10, None, None, 8])",
                        "(['MinStack', 'push', 'push', 'push', 'push', 'push', 'getMin', 'pop', 'getMin', 'pop', 'getMin'], [[], [1], [2], [0], [3], [4], [], [], [], [], []], [None, None, None, None, None, None, 0, None, 0, None, 0])",
                        "(['MinStack', 'push', 'getMin', 'push', 'getMin', 'push', 'getMin', 'top'], [[], [2147483647], [], [-2147483648], [], [0], [], []], [None, None, 2147483647, None, -2147483648, None, -2147483648, 0])",
                        "(['MinStack', 'push', 'push', 'push', 'push', 'push', 'top', 'getMin', 'pop', 'top', 'getMin', 'pop', 'getMin'], [[], [1], [1], [1], [1], [1], [], [], [], [], [], [], []], [None, None, None, None, None, None, 1, 1, None, 1, 1, None, 1])"
                    ]
                },
                "body": "        result = run_min_stack_operations(MinStack, operations, inputs)\n        assert_min_stack_operations(result, expected)"
            }
        ]
    },
    "playground_imports": "from helpers import run_min_stack_operations, assert_min_stack_operations\nfrom solution import MinStack",
    "playground_setup": "# Example test case\noperations = ['MinStack', 'push', 'push', 'push', 'getMin', 'pop', 'top', 'getMin']\ninputs = [[], [-2], [0], [-3], [], [], [], []]\nexpected = [None, None, None, None, -3, None, 0, -2]",
    "playground_run": "result = run_min_stack_operations(MinStack, operations, inputs)\nresult",
    "playground_assert": "assert_min_stack_operations(result, expected)"
}
