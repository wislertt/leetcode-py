{
    "problem_name": "minimum_height_trees",
    "solution_class_name": "Solution",
    "problem_number": "310",
    "problem_title": "Minimum Height Trees",
    "difficulty": "Medium",
    "topics": "Depth-First Search, Breadth-First Search, Graph, Topological Sort",
    "_tags": {
        "list": ["grind-75"]
    },
    "readme_description": "A tree is an undirected graph in which any two vertices are connected by *exactly* one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn *a list of all **MHTs'** root labels*. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.",
    "_readme_examples": {
        "list": [
            {
                "content": "<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e1.jpg\" style=\"width: 800px; height: 213px;\" />\n\n```\nInput: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]\nExplanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n```"
            },
            {
                "content": "<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e2.jpg\" style=\"width: 800px; height: 321px;\" />\n\n```\nInput: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\nOutput: [3,4]\n```"
            }
        ]
    },
    "readme_constraints": "- `1 <= n <= 2 * 10^4`\n- `edges.length == n - 1`\n- `0 <= ai, bi < n`\n- `ai != bi`\n- All the pairs `(ai, bi)` are distinct.\n- The given input is **guaranteed** to be a tree and there will be **no repeated** edges.",
    "readme_additional": "",
    "helpers_imports": "",
    "helpers_content": "",
    "helpers_run_name": "find_min_height_trees",
    "helpers_run_signature": "(solution_class: type, n: int, edges: list[list[int]])",
    "helpers_run_body": "    implementation = solution_class()\n    return implementation.find_min_height_trees(n, edges)",
    "helpers_assert_name": "find_min_height_trees",
    "helpers_assert_signature": "(result: list[int], expected: list[int]) -> bool",
    "helpers_assert_body": "    assert sorted(result) == sorted(expected)\n    return True",
    "solution_imports": "",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_find_min_height_trees, run_find_min_height_trees\nfrom .solution import Solution",
    "test_content": "",
    "test_class_name": "MinimumHeightTrees",
    "test_class_content": "    def setup_method(self):\n        self.solution = Solution()",
    "_solution_methods": {
        "list": [
            {
                "name": "find_min_height_trees",
                "signature": "(self, n: int, edges: list[list[int]]) -> list[int]",
                "body": "        # TODO: Implement find_min_height_trees\n        return []"
            }
        ]
    },
    "_test_helper_methods": {
        "list": [
            {
                "name": "setup_method",
                "parameters": "",
                "body": "self.solution = Solution()"
            }
        ]
    },
    "_test_methods": {
        "list": [
            {
                "name": "test_find_min_height_trees",
                "signature": "(self, n: int, edges: list[list[int]], expected: list[int])",
                "parametrize": "n, edges, expected",
                "test_cases": {
                    "list": [
                        "(4, [[1, 0], [1, 2], [1, 3]], [1])",
                        "(6, [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]], [3, 4])",
                        "(1, [], [0])",
                        "(2, [[0, 1]], [0, 1])",
                        "(3, [[0, 1], [1, 2]], [1])",
                        "(5, [[0, 1], [1, 2], [2, 3], [3, 4]], [2])",
                        "(7, [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5], [4, 6]], [1, 2])",
                        "(6, [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]], [3, 4])",
                        "(10, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]], [4, 5])",
                        "(8, [[0, 1], [1, 2], [2, 3], [0, 4], [4, 5], [5, 6], [6, 7]], [0, 4])",
                        "(9, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [4, 8]], [0, 1])",
                        "(11, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10]], [5])"
                    ]
                },
                "body": "        result = run_find_min_height_trees(Solution, n, edges)\n        assert_find_min_height_trees(result, expected)"
            }
        ]
    },
    "playground_imports": "from helpers import run_find_min_height_trees, assert_find_min_height_trees\nfrom solution import Solution",
    "playground_setup": "# Example test case\nn = 4\nedges = [[1,0],[1,2],[1,3]]\nexpected = [1]",
    "playground_run": "result = run_find_min_height_trees(Solution, n, edges)\nresult",
    "playground_assert": "assert_find_min_height_trees(result, expected)"
}
