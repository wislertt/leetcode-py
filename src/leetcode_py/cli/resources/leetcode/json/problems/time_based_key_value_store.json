{
    "problem_name": "time_based_key_value_store",
    "solution_class_name": "TimeMap",
    "problem_number": "981",
    "problem_title": "Time Based Key-Value Store",
    "difficulty": "Medium",
    "topics": "Hash Table, String, Binary Search, Design",
    "_tags": {
        "list": ["grind-75"]
    },
    "readme_description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n\nImplement the `TimeMap` class:\n\n- `TimeMap()` Initializes the object of the data structure.\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time `timestamp`.\n- `String get(String key, int timestamp)` Returns a value such that `set` was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\"\"`.",
    "_readme_examples": {
        "list": [
            {
                "content": "```\nInput\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\nOutput\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n```\n\n**Explanation:**\n```\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\ntimeMap.get(\"foo\", 1);         // return \"bar\"\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\ntimeMap.get(\"foo\", 5);         // return \"bar2\"\n```"
            }
        ]
    },
    "readme_constraints": "- `1 <= key.length, value.length <= 100`\n- `key` and `value` consist of lowercase English letters and digits.\n- `1 <= timestamp <= 10^7`\n- All the timestamps `timestamp` of `set` are strictly increasing.\n- At most `2 * 10^5` calls will be made to `set` and `get`.",
    "readme_additional": "",
    "helpers_imports": "",
    "helpers_content": "",
    "helpers_run_name": "time_map_operations",
    "helpers_run_signature": "(solution_class: type, operations: list[str], inputs: list[list])",
    "helpers_run_body": "    time_map = None\n    results: list[str | None] = []\n    for i, op in enumerate(operations):\n        if op == 'TimeMap':\n            time_map = solution_class()\n            results.append(None)\n        elif op == 'set' and time_map is not None:\n            time_map.set(*inputs[i])\n            results.append(None)\n        elif op == 'get' and time_map is not None:\n            results.append(time_map.get(*inputs[i]))\n    return results, time_map",
    "helpers_assert_name": "time_map_operations",
    "helpers_assert_signature": "(result: list, expected: list) -> bool",
    "helpers_assert_body": "    results, _ = result\n    assert results == expected\n    return True",
    "solution_imports": "",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_time_map_operations, run_time_map_operations\nfrom .solution import TimeMap",
    "test_content": "",
    "test_class_name": "TimeBasedKeyValueStore",
    "test_class_content": "",
    "_solution_methods": {
        "list": [
            {
                "name": "__init__",
                "signature": "(self) -> None",
                "body": "        # TODO: Initialize\n        pass"
            },
            {
                "name": "set",
                "signature": "(self, key: str, value: str, timestamp: int) -> None",
                "body": "        # TODO: Implement set\n        pass"
            },
            {
                "name": "get",
                "signature": "(self, key: str, timestamp: int) -> str",
                "body": "        # TODO: Implement get\n        return \"\""
            }
        ]
    },
    "_test_helper_methods": {
        "list": []
    },
    "_test_methods": {
        "list": [
            {
                "name": "test_time_map_operations",
                "signature": "(self, operations: list[str], inputs: list[list], expected: list)",
                "parametrize": "operations, inputs, expected",
                "test_cases": {
                    "list": [
                        "(['TimeMap', 'set', 'get', 'get', 'set', 'get', 'get'], [[], ['foo', 'bar', 1], ['foo', 1], ['foo', 3], ['foo', 'bar2', 4], ['foo', 4], ['foo', 5]], [None, None, 'bar', 'bar', None, 'bar2', 'bar2'])",
                        "(['TimeMap', 'get'], [[], ['key', 1]], [None, ''])",
                        "(['TimeMap', 'set', 'get'], [[], ['a', 'val', 1], ['a', 1]], [None, None, 'val'])",
                        "(['TimeMap', 'set', 'get', 'get'], [[], ['key', 'value', 5], ['key', 3], ['key', 7]], [None, None, '', 'value'])",
                        "(['TimeMap', 'set', 'set', 'get', 'get', 'get'], [[], ['x', 'v1', 1], ['x', 'v2', 2], ['x', 1], ['x', 2], ['x', 3]], [None, None, None, 'v1', 'v2', 'v2'])",
                        "(['TimeMap', 'set', 'set', 'set', 'get', 'get', 'get'], [[], ['k', 'a', 10], ['k', 'b', 20], ['k', 'c', 30], ['k', 15], ['k', 25], ['k', 35]], [None, None, None, None, 'a', 'b', 'c'])",
                        "(['TimeMap', 'set', 'set', 'get', 'get'], [[], ['key1', 'val1', 1], ['key2', 'val2', 2], ['key1', 1], ['key2', 2]], [None, None, None, 'val1', 'val2'])",
                        "(['TimeMap', 'set', 'set', 'set', 'get', 'get', 'get'], [[], ['a', 'x', 1], ['b', 'y', 2], ['c', 'z', 3], ['a', 1], ['b', 2], ['c', 3]], [None, None, None, None, 'x', 'y', 'z'])",
                        "(['TimeMap', 'set', 'get', 'set', 'get', 'set', 'get'], [[], ['test', 'first', 1], ['test', 1], ['test', 'second', 100], ['test', 50], ['test', 'third', 1000], ['test', 500]], [None, None, 'first', None, 'first', None, 'second'])",
                        "(['TimeMap', 'set', 'set', 'set', 'set', 'get'], [[], ['data', 'v1', 1], ['data', 'v2', 10], ['data', 'v3', 100], ['data', 'v4', 1000], ['data', 555]], [None, None, None, None, None, 'v3'])",
                        "(['TimeMap', 'set', 'get', 'get', 'get'], [[], ['single', 'value', 42], ['single', 1], ['single', 42], ['single', 100]], [None, None, '', 'value', 'value'])",
                        "(['TimeMap', 'set', 'set', 'get', 'get', 'get', 'get'], [[], ['boundary', 'min', 1], ['boundary', 'max', 10000000], ['boundary', 0], ['boundary', 1], ['boundary', 5000000], ['boundary', 10000000]], [None, None, None, '', 'min', 'min', 'max'])"
                    ]
                },
                "body": "        result = run_time_map_operations(TimeMap, operations, inputs)\n        assert_time_map_operations(result, expected)"
            }
        ]
    },
    "playground_imports": "from helpers import run_time_map_operations, assert_time_map_operations\nfrom solution import TimeMap",
    "playground_setup": "# Example test case\noperations = ['TimeMap', 'set', 'get', 'get', 'set', 'get', 'get']\ninputs = [[], ['foo', 'bar', 1], ['foo', 1], ['foo', 3], ['foo', 'bar2', 4], ['foo', 4], ['foo', 5]]\nexpected = [None, None, 'bar', 'bar', None, 'bar2', 'bar2']",
    "playground_run": "result = run_time_map_operations(TimeMap, operations, inputs)\nresult",
    "playground_assert": "assert_time_map_operations(result, expected)"
}
